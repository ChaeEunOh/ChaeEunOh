# 😄😄 Hi I'm ChaeEunOh 😄😄

## 🌱 Chap. 1
1-1) 변수 선언(variable, 식별자 a)

1-2) 변수 선언과 할당을 한번에 한 문장으로 표현 가능.

1-3) 불변성: 문자열 값과 숫자 값은 한 번 만든 값을 변경할 수 없음.

1-4) 참조형 데이터의 할당. (상수 or 변수 = 데이터)

1-5) 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당.

1-6) 중첩된 참조형 데이터의 프로퍼티에 할당.

1-7) 변수 복사의 비교 (기본형/참조형)

1-8) 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시

1-9) 변수 복사 이후 값 변경 결과 비교 - 참조형 데이터의 프로퍼티 값 변경이 아닌, 객체 자체를 변경했을 경우

1-10) 객체의 가변성에 따른 문제점: 값으로 전달 받은 객체에 변경을 가했을 때 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여주기 어려움.

1-11) 객체의 가변성에 따른 문제점의 해결 방법: changeName 함수가 새로운 객체를 반환하도록 수정 -> user와 user2는 서로 다른 객체이므로 변경 전과 후 비교 가능.

1-12) 얕은 복사: 기존 정보를 복사해서 새로운 객체를 반환하는 함수

1-13) copyObject를 이용한 객체 복사.

1-14) 중첩된 객체에 대한 얕은 복사: user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 새로운 데이터가 만들어지지만 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조 -> user.urls 프로퍼티에 대해서도 불변 객체를 만들 필요 있음.   

1-15) 중첩된 객체에 대한 깊은 복사: user.urls 프로퍼티에 대해서도 불변 객체 만듦.

1-16) 객체의 깊은 복사를 수행하는 범용함수 - copyObject 함수를 깊은 복사 방식으로 고침.

1-17) 깊은 복사

1-18) JSON을 활용한 간단한 깊은 복사

1-19) 자동으로 undefined를 부여하는 경우 (1) 값을 대입하지 않은 변수에 접근할 때 (2) 객체 내부의 존재하지 않는 프로퍼티에 접근할 때 (3) return 문이 없거나 호출되지 않는 함수의 실행 결과

1-20) undefined와 배열 - arr1) 빈 배열을 만듦 arr2) new 연산자와 함께 array 생성자 함수를 호출해 배열 인스턴스 생성 arr3) 각 요소에 undefined 부여.

1-21) 빈 요소와 배열의 순회 - 값을 대입하지 않은 변수는 아무것도 할당하지 않고 끝나며 할당이 안 된 변수에 접근하고자 할 때 undefined 반환.

1-22) undefined와 null의 비교 - '비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null 사용.


## 🌱 Chap. 2
2-1) 실행 컨텍스트와 콜 스택: 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여하는지 확인.

2-2) 매개변수와 변수에 대한 호이스팅 - 원본 코드

2-3) 매개변수와 변수에 대한 호이스팅 - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태

2-4) 매개변수와 변수에 대한 호이스팅 - 호이스팅을 마친 상태

2-5) 함수 선언의 호이스팅 - 원본 코드 

2-6) 함수 선언의 호이스팅 - 호이스팅을 마친 상태

2-7) 함수 선언의 호이스팅 - 함수 선언문을 함수 표현식으로 바꾼 코드

2-8) 함수를 정의하는 세 가지 방식 - 함수 선언문, 익명 함수 표현식, 기명 함수 표현식

2-9) 함수 선언문과 함수 표현식 - 원본 코드

2-10) 함수 선언문과 함수 표현식 - 호이스팅을 마친 상태

2-11) 함수 선언문의 위험성 - 같은 이름의 함수가 선언되어 있다면 가장 나중에 있는 함수로 덧씌워짐.

2-12) 함수 표현식의 안정성 

2-13) 스코프 체인 - 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것


## 🌱 Chap. 3
3-1) 전역 공간에서의 this(브라우저 환경) - 브라우저 환경에서는 전역객체가 window

3-2) 전역 공간에서의 this(Node.js 환경) - Node.js 환경에서는 전역객체가 global

3-3) 전역변수와 전역객체 - 전역공간에서의 this는 전역객체를 의미하므로 두 값이 같은 값을 출력.

3-4) 전역변수와 전역객체 - 전역공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당해도 상관없음.

3-5) 전역변수와 전역객체 - delete 시에는 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있음.

3-6) 함수로서 호출, 메서드로서 호출 - 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우엠나 메서드로 동작하고, 그렇지 않으면 함수로 동작.

3-7) 메서드로서 호출 - 점 표기법, 대괄호 표기법 (어떤 함수를 호출할 때 그 함수 이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출, 그렇지 않은 모든 경우에는 함수로 호출한 것.)

3-8) 메서드 내부에서의 this

3-9) 내부 함수에서의 this

3-10) 내부함수에서의 this를 우회하는 방법 -  outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFun2의 경우 self에는 객체 obj가 출력.

3-11) this를 바인딩하지 않는 함수(화살표 함수)

3-12) 콜백 함수 내부에서의 this - 함수 A의 제어권을 다른 함수 B에게 넘겨주는 경우 함수 A를 콜백 함수라고 하며, this는 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정됨.

3-13) 생성자 함수 - new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 됨.

3-14) call 메서드 - 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령.

3-15) call 메서드 

3-16) apply 메서드 - 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정함.

3-17) call/apply 메서드의 활용 - 유사배열객체에 배열 메서드를 적용

3-18) call/apply 메서드의 활용 - arguments, NodeList에 배열 메서드를 적용

3-19) call/apply 메서드의 활용 - 문자열에 배열 메서드 적용

3-20) call/apply 메서드의 활용 - ES6의 Array.from 메서드

3-21) call/apply 메서드의 활용 - 생성자 내부에서 다른 생성자 호출

3-22) call/apply 메서드의 활용 - 최대/최솟을 구하는 코드 구현

3-23) call/apply 메서드의 활용 - 여러 인수를 받는 메서드(Math.max/Math.min)에 apply를 적용

3-24) call/apply 메서드의 활용 - ES6의 펼치기 연산자 활용

3-25) bind 메서드 - this 지정과 부분 적용 함수 구현

## 🌱 Chap. 4
4-1) callback function은 다른 코드에게 인자를 넘겨줌으로써 그 제어권도 함께 임위한 함수

4-2) setInterval에 전달한 첫 번째 인자인 callback function함수는 0.3초마다 실행

4-3) callback func. Array.prototype.map

4-4) callback func. Array.prototype.map - 인자의 순서를 임의로 바꾸어 사용한 경우

4-5) callback func. Array.prototype.map 구현
 
4-6) 콜백 함수 내부에서의 this

4-7) 메서드를 콜백 함수로 전달한 경우

4-8) 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법 - 전통적인 방식

4-9) 콜백 함수 내부에서의 this를 사용하지 않은 경우

4-10) 예제 4-8의 func 함수 재활용

4-11) 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법

4-12) 콜백 함수 내부의 this에 다른 값 바인딩하기

4-13) 콜백지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상

4-14) 비동기 작업의 동기적 표현(1) - Promise(1)

4-15) 비동기 작업의 동기적 표현(2) - Promise(2)

4-16) 비동기 작업의 동기적 표현(3) - Generator

4-17) 비동기 작업의 동기적 표현 - Promise + async/await

## 🌱 Chap. 5
5-1) 외부 함수의 변수를 참조하는 내부 함수(1)

5-2) 외부 함수의 변수를 참조하는 내부 함수(2)

5-3) 외부 함수의 변수를 참조하는 내부 함수(3)

5-4) (1) setInterval/setTimeout (2) eventListener

5-5) (1) return에 의한 클로저의 메모리 해제 (2) setInterval에 의한 클로저의 메모리 해제 (3) eventListener에 의한 클로저의 메모리 해제
 
5-6) 콜백 함수와 클로저(1), 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

5-7) 콜백 함수와 클로저(2)

5-8) 콜백 함수와 클로저(3)

5-9) 백 함수와 클로저(4)

5-10) 간단한 자동차 객체

5-11) 클로저로 변수를 보호한 자동차 객체(1)

5-12) 클로저로 변수를 보호한 자동차 객체(2)

5-13) bind 메서드를 활용한 부분 적용 함수, 부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 나중에 (n-m)개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수이다.

5-14) 부분 적용 함수 구현(1)
 
5-15) 부분 적용 함수 구현(2)

5-16) 부분 적용 함수 예시 - 디바운스, 디바운스(devounce)는 짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것
 
5-17) 커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있는 체인 형태로 구성한 것을 말한다.

5-18) 필요한 인자 개수만큼 함수를 만들어 계속 리턴해주다가 마지막에만 조합해서 리턴하면 되기 때문에 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이하다. 다만 인자가 많아질수록 가독성이 떨어진다는 단점이 있다.

## 🌱 Chap. 6
6-1) Person 객체 생성 후 해당 객체의 이름을 저장하고 반환하는 메서드를 제공.

6-2) 생성자 함수와 프로토타입을 사용하여 객체를 생성 후 생성자 함수와 객체의 구조를 콘솔에 출력.

6-3) 배열 객체와 그 생성자 함수를 통 새로운 배열을 생성

6-4) 다양한 데이터 타입을 포함하는 배열 dataTypes를 정의 후, 각 데이터 타입의 constructor를 NewConstructor 함수로 바꾼 뒤, 해당 객체가 NewConstructor의 인스턴스인지 확인.

6-5) Person 객체를 생성 후 생성된 객체가 Person의 인스턴스인지 확인.
 
6-6) Person 객체의 메서드 getName을 iu 객체에서 다시 정의하여 객체의 동작을 변경.

6-7) 배열에 요소를 추가하고 hasOwnProperty 메서드를 통해 배열 객체의 특정 인덱스가 직접 소유되었는지 확인.

6-8) 배열의 toString 메서드를 직접 재정의하여 원하는 형태의 문자열로 반환할 수 있음.

6-9) Object.prototype.getEntries 메서드를 정의하고, 객체의 속성과 값을 배열 형로 반환

6-10) Grade 생성자 함수 정의 후 객체 생성

## 🌱 Chap. 7
7-1) Rectangle 생성자 함수를 활용한 객체 생성 및 정적 메서드 추가

7-2) Grade 생성자 함수를 활용한 배열과 유사한 객체 생성

7-3) 배열 메서드인 push를 통해 객체에 새로운 요소를 추가

7-4) Grade.prototype을 배열로 설정하여 객체들이 배열처럼 동작하고, length 속성 delte를 통해 일반 객체로 돌아감.

7-5) Rectangle과 Square 생성자 함수 정의 후, 각각의 프로토타입에 getArea 메서드를 추가하여 사각형과 정사각형의 넓이를 계산
 
7-6) Rectangle 생성자 함수는 너비와 높이를 받아 직사각형을 생성하고, Square 생성자 함수는 변의 길이를 받아 정사각형을 생성함.

7-7) Rectangle과 Square 생성자 함수를 사용하여 직사각형과 정사각형의 넓이를 계산

7-8) extendClass1 함수는 프로토타입 체인을 통해 상속을 설정하고, 추가적인 메서드를 정의함.

7-9) extendClass2 함수를 사용하여 JavaScript에서 클래스를 확장하고 서브 클래스를 생성

7-10) Rectangle 클래스를 상속하여 Square 클래스를 구현

7-11) extendClass1 구현

7-12) extendClass2 구현

7-13) extendClass3를 구현

7-14) 상속과 메서드 오버라이딩을 구현하면서 super 키워드를 통해 부모 클래스의 메서드를 호출

7-15) ES5와 ES6의 클래스 정의 방식 비교

7-16) ES6에서 클래스를 정의하고 상속을 통해 구현
