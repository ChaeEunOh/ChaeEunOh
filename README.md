# 😄😄 Hi I'm ChaeEunOh 😄😄

## 🌱 Chap. 1
1-1) 변수 선언(variable, 식별자 a)

1-2) 변수 선언과 할당을 한번에 한 문장으로 표현 가능.

1-3) 불변성: 문자열 값과 숫자 값은 한 번 만든 값을 변경할 수 없음.

1-4) 참조형 데이터의 할당. (상수 or 변수 = 데이터)

1-5) 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당.

1-6) 중첩된 참조형 데이터의 프로퍼티에 할당.

1-7) 변수 복사의 비교 (기본형/참조형)

1-8) 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시

1-9) 변수 복사 이후 값 변경 결과 비교 - 참조형 데이터의 프로퍼티 값 변경이 아닌, 객체 자체를 변경했을 경우

1-10) 객체의 가변성에 따른 문제점: 값으로 전달 받은 객체에 변경을 가했을 때 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여주기 어려움.

1-11) 객체의 가변성에 따른 문제점의 해결 방법: changeName 함수가 새로운 객체를 반환하도록 수정 -> user와 user2는 서로 다른 객체이므로 변경 전과 후 비교 가능.

1-12) 얕은 복사: 기존 정보를 복사해서 새로운 객체를 반환하는 함수

1-13) copyObject를 이용한 객체 복사.

1-14) 중첩된 객체에 대한 얕은 복사: user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 새로운 데이터가 만들어지지만 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조 -> user.urls 프로퍼티에 대해서도 불변 객체를 만들 필요 있음.   

1-15) 중첩된 객체에 대한 깊은 복사: user.urls 프로퍼티에 대해서도 불변 객체 만듦.

1-16) 객체의 깊은 복사를 수행하는 범용함수 - copyObject 함수를 깊은 복사 방식으로 고침.

1-17) 깊은 복사

1-18) JSON을 활용한 간단한 깊은 복사

1-19) 자동으로 undefined를 부여하는 경우 (1) 값을 대입하지 않은 변수에 접근할 때 (2) 객체 내부의 존재하지 않는 프로퍼티에 접근할 때 (3) return 문이 없거나 호출되지 않는 함수의 실행 결과

1-20) undefined와 배열 - arr1) 빈 배열을 만듦 arr2) new 연산자와 함께 array 생성자 함수를 호출해 배열 인스턴스 생성 arr3) 각 요소에 undefined 부여.

1-21) 빈 요소와 배열의 순회 - 값을 대입하지 않은 변수는 아무것도 할당하지 않고 끝나며 할당이 안 된 변수에 접근하고자 할 때 undefined 반환.

1-22) undefined와 null의 비교 - '비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null 사용.


## 🌱 Chap. 2
2-1) 실행 컨텍스트와 콜 스택: 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여하는지 확인.

2-2) 매개변수와 변수에 대한 호이스팅 - 원본 코드

2-3) 매개변수와 변수에 대한 호이스팅 - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태

2-4) 매개변수와 변수에 대한 호이스팅 - 호이스팅을 마친 상태

2-5) 함수 선언의 호이스팅 - 원본 코드 

2-6) 함수 선언의 호이스팅 - 호이스팅을 마친 상태

2-7) 함수 선언의 호이스팅 - 함수 선언문을 함수 표현식으로 바꾼 코드

2-8) 함수를 정의하는 세 가지 방식 - 함수 선언문, 익명 함수 표현식, 기명 함수 표현식

2-9) 함수 선언문과 함수 표현식 - 원본 코드

2-10) 함수 선언문과 함수 표현식 - 호이스팅을 마친 상태

2-11) 함수 선언문의 위험성 - 같은 이름의 함수가 선언되어 있다면 가장 나중에 있는 함수로 덧씌워짐.

2-12) 함수 표현식의 안정성 

2-13) 스코프 체인 - 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것


## 🌱 Chap. 3
3-1) 전역 공간에서의 this(브라우저 환경) - 브라우저 환경에서는 전역객체가 window

3-2) 전역 공간에서의 this(Node.js 환경) - Node.js 환경에서는 전역객체가 global

3-3) 전역변수와 전역객체 - 전역공간에서의 this는 전역객체를 의미하므로 두 값이 같은 값을 출력.

3-4) 전역변수와 전역객체 - 전역공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당해도 상관없음.

3-5) 전역변수와 전역객체 - delete 시에는 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있음.

3-6) 함수로서 호출, 메서드로서 호출 - 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우엠나 메서드로 동작하고, 그렇지 않으면 함수로 동작.

3-7) 메서드로서 호출 - 점 표기법, 대괄호 표기법 (어떤 함수를 호출할 때 그 함수 이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출, 그렇지 않은 모든 경우에는 함수로 호출한 것.)

3-8) 메서드 내부에서의 this

3-9) 내부 함수에서의 this

3-10) 내부함수에서의 this를 우회하는 방법 -  outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFun2의 경우 self에는 객체 obj가 출력.

3-11) this를 바인딩하지 않는 함수(화살표 함수)

3-12) 콜백 함수 내부에서의 this - 함수 A의 제어권을 다른 함수 B에게 넘겨주는 경우 함수 A를 콜백 함수라고 하며, this는 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정됨.

3-13) 생성자 함수 - new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 됨.

3-14)

3-15)

3-16)

3-17)

3-18)

3-19)

3-20)

3-21)

3-22)

3-23)

3-24)

3-25)

